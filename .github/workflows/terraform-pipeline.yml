name: Terraform Deployment

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: 
      name: prod
    
    # Use the Bash shell regardless of the OS runner
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository
    - name: Checkout
      uses: actions/checkout@v4

    # Install Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.7.0

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: af-south-1

    # Check if backend exists before trying to create it
    - name: Check if backend exists
      id: check_backend
      run: |
        aws s3api head-bucket --bucket ${{ secrets.TERRAFORM_STATE_BUCKET }} 2>/prod/null || echo "create_backend=true" >> $GITHUB_OUTPUT

    # Initialize and apply the backend configuration only if needed
    - name: Terraform Backend Init
      if: steps.check_backend.outputs.create_backend == 'true'
      run: |
        cd terraform/global/s3-backend
        terraform init
        terraform plan

    - name: Terraform Backend Apply
      if: steps.check_backend.outputs.create_backend == 'true'
      run: |
        cd terraform/global/s3-backend
        terraform apply -auto-approve

    # Set environment
    - name: Set environment variables
      run: |
        echo "ENVIRONMENT=prod" >> $GITHUB_ENV

    # Set up backend configuration
    - name: Create backend tfvars file
      run: |
        cat > terraform/environments/prod/backend.tfvars << EOF
        bucket         = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        key            = "prod/terraform.tfstate"
        region         = "af-south-1"
        dynamodb_table = "${{ secrets.TERRAFORM_LOCK_TABLE }}"
        encrypt        = true
        EOF
        
    # Set up terraform variables
    - name: Create terraform tfvars file
      run: |
        cat > terraform/environments/prod/terraform.tfvars << EOF
        aws_region     = "af-south-1"
        project_name   = "${{ vars.PROJECT_NAME }}"
        vpc_cidr       = "${{ vars.VPC_CIDR }}"
        db_identifier  = "${{ vars.DB_IDENTIFIER }}"
        db_name        = "${{ vars.DB_NAME }}"
        db_username    = "${{ secrets.DB_USERNAME }}"
        db_password    = "${{ secrets.DB_PASSWORD }}"
        db_instance_class = "${{ vars.DB_INSTANCE_CLASS }}"
        db_engine_version = "${{ vars.DB_ENGINE_VERSION }}"
        allocated_storage = ${{ vars.ALLOCATED_STORAGE }}
        db_multi_az    = false
        db_skip_final_snapshot = true
        required_subnet_count = 2
        eb_solution_stack_name = "${{ vars.EB_SOLUTION_STACK }}"
        eb_instance_type       = "t3.micro"
        eb_min_instances       = 1
        eb_max_instances       = 2
        environment            = "prod"
        EOF
        
    # Initialize Terraform working directory
    - name: Terraform Init
      run: |
        cd terraform/environments/prod
        terraform init -backend-config=backend.tfvars

    # Validate Terraform configuration
    - name: Terraform Validate
      run: |
        cd terraform/environments/prod
        terraform validate -no-color

    # Plan Terraform changes
    - name: Terraform Plan
      id: plan
      run: |
        cd terraform/environments/prod
        terraform plan -var-file=terraform.tfvars -no-color -out=tfplan
        terraform show -json tfplan > plan.json
        echo "has_changes=$(jq -r '.resource_changes | length > 0' plan.json)" >> $GITHUB_OUTPUT

    # Apply Terraform changes
    - name: Terraform Apply
      id: apply
      if: steps.plan.outputs.has_changes == 'true'
      run: |
        cd terraform/environments/prod
        terraform apply -var-file=terraform.tfvars -auto-approve
        
    # Capture output for reference
    - name: Capture terraform outputs
      if: steps.apply.outcome == 'success'
      run: |
        cd terraform/environments/prod
        terraform output -json | jq 'del(.db_password, .db_username)' > tf_outputs.json
        
    # Post-deployment verification
    # - name: Verify deployment
    #   if: steps.apply.outcome == 'success'
    #   run: |
    #     echo "Running post-deployment verification checks..."
    #     # Add verification steps here, e.g.:
    #     # - Health check endpoints
    #     # - Resource availability checks
    #     # - Database connection tests